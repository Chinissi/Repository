// Package gen allows generating Go structs from avro schemas.
package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"strings"
	"text/template"

	"github.com/hamba/avro"
	"github.com/iancoleman/strcase"
)

// Config exposes the options available for the code generation.
type Config struct {
	PackageName string
	Tags        map[string]TagStyle
}

type generator struct {
	Config
}

// TagStyle defines the styling for a tag.
type TagStyle string

const (
	// Snake is a style like im_written_in_snake_case.
	Snake TagStyle = "snake"
	// Camel is a style like imWrittenInCamelCase.
	Camel = "camel"
	// Kebab is a style like im-written-in-kebab-case.
	Kebab = "kebab"
	// UpperCamel is a style like ImWrittenInUpperCamel.
	UpperCamel = "upper-camel"
)

const outputTemplate = `// Code generated by avro/gen. DO NOT EDIT.
package {{ .PackageName }}

{{ if len .Imports }}
import (
    {{- range .Imports }}
		"{{ . }}"
	{{- end }}
)
{{ end }}

{{- range .Typedefs }}
type {{ .Name }} struct {
	{{- range .Fields }}
		{{ .Name }} {{ .Type }} {{ .Tag }}
	{{- end }}
}
{{ end }}`

type data struct {
	PackageName string
	Imports     []string
	Typedefs    []typedef
}

type typedef struct {
	Name   string
	Fields []field
}

type field struct {
	Name string
	Type string
	Tag  string
}

var primitiveMappings = map[avro.Type]string{
	"string":  "string",
	"bytes":   "[]byte",
	"int":     "int",
	"long":    "int64",
	"float":   "float32",
	"double":  "float64",
	"boolean": "bool",
}

// Struct generates Go structs based on the schema s and writes them to dst.
func Struct(s string, dst io.Writer, gc Config) error {
	schema, err := avro.Parse(s)
	if err != nil {
		return err
	}

	rSchema, ok := schema.(*avro.RecordSchema)
	if !ok {
		return errors.New("can only generate Go code from Record Schemas")
	}

	td := data{PackageName: strcase.ToSnake(gc.PackageName)}
	_ = generator{Config: gc}.generateFrom(rSchema, &td)

	buf := &bytes.Buffer{}
	if err = writeCode(buf, &td); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed formatting. %w", err)
	}

	_, err = dst.Write(formatted)
	return err
}

func (g generator) generateFrom(schema avro.Schema, acc *data) string {
	switch t := schema.(type) {
	case *avro.RecordSchema:
		typeName := strcase.ToCamel(t.Name())
		fields := make([]field, len(t.Fields()))
		for i, f := range t.Fields() {
			fSchema := f.Type()
			fieldName := strcase.ToCamel(f.Name())
			typ := g.resolveType(fSchema, f.Prop("logicalType"), acc)
			tag := f.Name()
			fields[i] = g.newField(fieldName, typ, tag)
		}
		acc.Typedefs = append(acc.Typedefs, newType(typeName, fields))
		return typeName
	default:
		return g.resolveType(schema, nil, acc)
	}
}

func (g generator) resolveType(fieldSchema avro.Schema, logicalType interface{}, acc *data) string {
	var typ string
	switch s := fieldSchema.(type) {
	case *avro.RefSchema:
		typ = resolveRefSchema(s)
	case *avro.RecordSchema:
		typ = g.generateFrom(s, acc)
	case *avro.PrimitiveSchema:
		typ = resolvePrimitiveLogicalType(logicalType, typ, s)
		if strings.Contains(typ, "time") {
			addImport(acc, "time")
		}
		if strings.Contains(typ, "big") {
			addImport(acc, "math/big")
		}
	case *avro.ArraySchema:
		typ = fmt.Sprintf("[]%s", g.generateFrom(s.Items(), acc))
	case *avro.EnumSchema:
		typ = "string"
	case *avro.FixedSchema:
		typ = fmt.Sprintf("[%d]byte", +s.Size())
	case *avro.MapSchema:
		typ = "map[string]" + g.resolveType(s.Values(), nil, acc)
	case *avro.UnionSchema:
		typ = g.resolveUnionTypes(s, acc)
	}
	return typ
}

func resolveRefSchema(s *avro.RefSchema) string {
	typ := ""
	if sx, ok := s.Schema().(*avro.RecordSchema); ok {
		typ = sx.Name()
	}
	return strcase.ToCamel(typ)
}

func (g generator) resolveUnionTypes(unionSchema *avro.UnionSchema, acc *data) string {
	nullIsAllowed := false
	typesInUnion := make([]string, 0)
	for _, elementSchema := range unionSchema.Types() {
		if _, ok := elementSchema.(*avro.NullSchema); ok {
			nullIsAllowed = true
		} else {
			typesInUnion = append(typesInUnion, g.generateFrom(elementSchema, acc))
		}
	}
	if nullIsAllowed && len(typesInUnion) == 1 {
		typ := typesInUnion[0]
		if strings.HasPrefix(typ, "[]") {
			return typ
		}
		return "*" + typ
	}
	return "interface{}"
}

func resolvePrimitiveLogicalType(logicalType interface{}, typ string, s avro.Schema) string {
	switch logicalType {
	case "", nil:
		typ = primitiveMappings[s.Type()]
	case "date", "timestamp-millis", "timestamp-micros":
		typ = "time.Time"
	case "time-millis", "time-micros":
		typ = "time.Duration"
	case "decimal":
		typ = "*big.Rat"
	}
	return typ
}

func newType(name string, fields []field) typedef {
	return typedef{
		Name:   name,
		Fields: fields,
	}
}

func (g generator) newField(name, typ, tag string) field {
	tagLine := fmt.Sprintf(`avro:"%s"`, tag)
	for tagName, style := range g.Tags {
		if tagName == "avro" {
			continue
		}
		tagLine += fmt.Sprintf(` %s:"%s"`, tagName, g.tagStyleFn(style)(tag))
	}
	return field{
		Name: name,
		Type: typ,
		Tag:  fmt.Sprintf("`%s`", tagLine),
	}
}

func (g generator) tagStyleFn(style TagStyle) func(string) string {
	switch style {
	case Kebab:
		return strcase.ToKebab
	case UpperCamel:
		return strcase.ToCamel
	case Camel:
		return strcase.ToLowerCamel
	case Snake:
		return strcase.ToSnake
	}
	return func(s string) string {
		return s
	}
}

func addImport(acc *data, statement string) {
	for _, k := range acc.Imports {
		if k == statement {
			return
		}
	}
	acc.Imports = append(acc.Imports, statement)
}

func writeCode(w io.Writer, data *data) error {
	parsed, err := template.New("out").Parse(outputTemplate)
	if err != nil {
		return err
	}

	return parsed.Execute(w, data)
}
